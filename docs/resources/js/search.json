[[{"l":"Welcome","p":["Welcome to the documentation of dotnetfile, a Common Language Runtime (CLR) header parser library for Windows .NET files built in Python. The CLR header is present in every Windows .NET assembly beside the Portable Executable (PE) header. It stores a plethora of metadata information for the managed part of the file. dotnetfile is in a way the equivalent of pefile but for .NET samples.","This website gives an overview of the project, why we build it and what you can do with it. This project is a work in progress, meaning we'll continuously expand it with new functionality.","If you find any issues, have suggestions or want to see new features, please report them to the GitHub project page: https://github.com/pan-unit42/dotnetfile"]}],[{"l":"Introduction","p":["We created this project for several reasons. First, while the PE header is documented extensively and used in various ways for malware identification, the CLR header isn't. This is unfortunate, as it offers plenty of information on a .NET assembly that can be useful to detect malware.","Second, there is a lack of public libraries available to parse the header of .NET assemblies that can be easily utilized on scale. There are great projects available like dnlib, AsmResolver or PEReader. However, they're all build in C# which makes it difficult to use if you're not proficient in that language. Also, some are not very comprehensive and poorly documented.","There are some promising open source projects written in Python like netfile and dnfile. However, they partly suffer from the same issues as the libraries built in C#, although the latter one looks quite comprehensive in functionality.","Lastly, we didn't only want to provide an easy-to-use API, but also try to contribute new methods to improve file detection. This includes the MemberRef hash(experimental) and the original and a modified version of TypeRef hash.","The aim of this project is to give malware analysts and threat hunters a tool to easily pull out information from the CLR header. You don't need to be an expert in the CLR header and get lost in its specification to use this library. By using the API, you'll also learn how the header is structured and hopefully get a better understanding of this file type in general.","Finally, we want to encourage other people to start digging into the CLR header to find more information that can be used to identify malware."]}],[{"l":"Project structure","p":["The project is made of the main library dotnetfile that is an interface to the CLR header parser. It offers easy to use methods to pull out data collected by the parser. As we use some functionality of pefile, the project can be seen as an extension of it. All methods provided by pefile can be also used in dotnetfile. The project structure is as follows.","Interface:","dotnetfile.py","Parser:","parser.py","constants.py","metadata_rows.py","structures.py","util.py","Logger:","logger.py","We encourage you to only use the dotnetfile interface as it offers easy to use methods to pull out information from the header. However, there might be situations were you search for something that isn't supported yet in dotnetfile. In this case, you can also directly get the data collected by the parser. But these internal data structures aren't heavily documented and might be difficult to understand when you're not familiar with the CLI specification."]}],[{"l":"Requirements","p":["In order to use dotnetfile you need to have at least Python v3.7 installed.","Additionally, you need to install the Python module pefile, a Portable Executable reader. You can easily install it with the help of PIP: pip3 install pefile"]}],[{"l":"Installation"},{"l":"PyPI","p":["You can easily install dotnetfile with pip:","pip install dotnetfile"]},{"l":"Local setup","p":["To install dotnetfile as a module, please use the provided setup.py file. This can be done with the help of Python: python3 setup.py install","Now, you're all set to use dotnetfile. \uD83D\uDE4C"]}],[{"l":"Usage"},{"l":"General","p":["To use dotnetfile, all you have to do is to import the module and create an instance of the class DotNetPE with the .NET assembly path as a parameter. A minimal example that prints out the number of streams of an assembly is shown below:","Before using a method that resides in a metadata table class, you should always check if the appropriate table is present in the .NET file. This might take a bit of time to get familiar with, but on the other side you'll learn how the header is organized. It can be accomplished in several ways:","For short codes, you can use the try...except statement. Example to get the assembly name:","For short codes and as a cleaner solution, you can also use the metadata_table_exists() method. Example to get the assembly name:","For longer codes, you can use the existent_metadata_tables() method. Example to get the assembly and module names:"]},{"l":"Fast load","p":["Since dotnetfile v0.2.4, use can use fast load options when loading a file with DotNetPE(). This was introduced to more quickly parse bigger .NET files that sometimes take very long to be loaded. There are several stages of fast load that can be used subsequently or independently together with the full load method, depending on your needs."]},{"l":"Fast load options","p":["header_only- Load only header data and skip metadata table loading.","normal- Load header data and only those metadata tables supported in the interface library. Optionally, you can choose your own list of metadata tables to be loaded via fast_load_tables=. However, it's advised not to change the default list unless you really know what you are doing.","normal_resources- Load header data, only those metadata tables supported in interface library and the resources. Again, you can choose your own list of metadata tables to be loaded via fast_load_tables=.","By default, when no fast load option is used, all data is loaded which can be slow for big files."]},{"l":"Full load options","p":["When you have used a fast loading option, you have to eventually load the remaining data at some point. For this, there's the full_load_data() method which the full load option passed as a parameter.","normal- Load header data and only those metadata tables supported in interface library. Possible preceding fast load option: header_only","normal_resources- Depending on the previous fast load option(s), load only those metadata tables supported in interface library and the resources or only the resources. Possible preceding fast load option(s): header_only, normal","full- Depending on the previous fast load option(s), load all or only the remaining metadata tables supported in interface library. Possible preceding fast load option(s): header_only, normal, normal_resource"]},{"l":"Example","p":["The following code example uses the fast load option header_only to get basic header information. It checks if an assembly has .NET resources before actually parsing them (together with the necessary metadata tables) with the full load option normal_resources. Batch processing samples to find those with resources in such a way is much faster than to fully parse each assembly to get the data.","Keep in mind that when you do not load all the metadata tables and want to get the full list of strings, it might be incomplete."]}],[{"l":"File identification","p":["This section contains methods that can be used for static identification of .NET assemblies. These methods can be useful for malware detection, threat hunting or sample aggregation."]}],[{"l":"MemberRef hash","p":["The MemberRef hash is a purely experimental hash method and hasn't been tested yet. The idea was to create a hash method that also works with obfuscated malware. The MemberRef table contains mostly .NET runtime constructs like methods, properties, fields and so on, which can't be easily obfuscated. This could be a more reliable hash method than for example TypeRef hash, but still has to be proven.","The MemberRef hash uses the referenced member name of the table rows and the table names ( Name) of the corresponding classes ( Class). This TableNameOfBelongingClass-MemberName string pair is added to a list and the hash value is calculated at the end, so basically the same procedure as in the TypeRef hash. The class always belongs to one of the five tables TypeDef, TypeRef, ModuleRef, MethodDef or TypeSpec.","The list of table and member names can be sorted alphabetically after the reference names before being hashed. Strings are used case-sensitive."]},{"l":"Malware example","p":["Hash (SHA-256): 6f30280da560a30bbe25835f00d881dad94e5a7641b63e028080628c1f82a992","This is an unobfuscated .NET EXE malware with the following MemberRef table: MemberRef table content of the malware","As can be seen that the majority of referenced member names are present in cleartext. There's only a small amount of strings which are obfuscated.","We can calculate the different MemberRef hash possibilities with the following example code:","The result is as follows:","Which combination makes more sense is up to you, if you want to use this hash method.","As an example of how the list of TableNameOfBelongingClass-MemberName name pairs looks like before it gets hashed, the following list excerpt shows the unsorted version:"]}],[{"i":"typeref-hash-modified","l":"TypeRef hash (modified)","p":["The TypeRef hash was made popular by GData, but it seems this method was introduced earlier in ClrGuard. The implementation by GData takes the referenced type names and their corresponding namespace names from the TypeRef table and creates a SHA-256 hash value. For a detailed description, please take a look at their blog post.","We have slightly modified GData's implementation in the following way. Instead of the namespace names, we use the resolution scope names as they're always present. While every reference type has a corresponding resolution scope, it doesn't need to have a corresponding namespace. Additionally, you can optionally skip types that reference each other as added by some .NET protectors (see TypeRef table has self-referencing entries). This results in some sort of cleared TypeRef hash that might be slightly more reliable. Furthermore, the list of scope and type names can be sorted alphabetically after the type names before being hashed. Strings are also used case-sensitive and everything else is also identical."]},{"l":"Malware example","p":["Hash (SHA-256): 6f30280da560a30bbe25835f00d881dad94e5a7641b63e028080628c1f82a992","This is an unobfuscated .NET EXE malware with the following TypeRef table: TypeRef table content of the malware","As can be seen, there are referenced types like SpecialFolder that don't have a corresponding namespace, but always have a resolution scope.","We can calculate the different TypeRef hash possibilities with the following example code:","The result is as follows:","Which combination makes more sense is up to you, if you want to use this hash method.","As an example of how the list of ResolutionScope-ReferencedType name pairs looks like before it gets hashed, the following list excerpt shows the unsorted + excluded self-referenced entries version:"]}],[{"l":"API documentation","p":["We created the API based on the structure of the CLR header itself. This means that we provide different methods based on the information of the various tables. Every metadata table that we support has a class that contains methods to pull out information from the very same. While it might need a bit of thinking at first to get familiar with the CLR tables and contained information, you will also learn how the header is organized."]}],[{"l":"General","p":["General methods are functions that can't be assigned to a specific table or header and are thus part of the main DotNetPE class."]},{"l":"Metadata table existence","p":["Checks if a metadata table exists based on its name.","Parameters:","Name of the table","Return value:","True or False","Example:"]},{"l":"Get existent metadata tables","p":["Get a list of existent metadata tables.","Parameters:","-","Return value:","List with metadata table name strings","Example:"]},{"l":"Native image check","p":["Check if assembly is a native image.","Native images are .NET files that are created with the Windows Native Image Generator Ngen.exe. This tool creates a precompiled native version of a .NET assembly which can be seen as a cached version of the original file. Such a file already contains the native code that is usually created by the JIT compiler at runtime. Thus, these samples are often faster in execution. Consequentially, native images are platform dependant. Also, a disadvantage of native images is that they are much bigger size of the file compared to the original version. Native Image Generator Usually, native images have the import table stripped and contain an additional section. Therefore, these files are not executable on their own and have to be executed in a special way. However, it is not documented how this happens nor how the image creation itself is done. Also, while you can manually create a native image of your .NET file, there is the Windows service called Native Image Service and starting from Windows 8 and .NET Framework 4.5 the Windows Image Task which seem to automatically create them. Again, how and on what conditions this happens is not documented.","Native Image Service Native Image Task","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Mixed assembly check","p":["Check if assembly is a mixed assembly.","Mixed assemblies are .NET files that have both managed and unmanaged code. Compared to normal .NET assemblies, they have more than just the one imported function _CoreExeMain(EXE) or _CorDllMain(DLL) from mscoree.dll on the native side. But also the managed side looks much different with a plethora of initialization namespace, types and methods. Mixed assemblies These files are normally created with Visual C++ and the C++/CLI extension. C++/CLI is some sort of dialect of C++ created for the production of .NET assemblies with the C++ compiler. C++/CLI extension Usually, you can find the namespaces CrtImplementationDetails and CppImplementationDetails in mixed assemblies, but there are also exceptions. You can also build mixed assemblies \"manually\". An example can be found as part of an open-source code for CVE-2019-18935: CVE-2019-18935 payload The example shows how to use an empty dummy C# file for the managed part and shellcode for the unmanaged one. The result is a .NET assembly with no managed code and the whole functionality contained in the native part.","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Native entry point existence","p":["Check if assembly has a native entry point.","A .NET assembly that has a native entry point is always a mixed assembly.","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Windows Forms app check","p":["Check if assembly is a Windows Forms app.","A Windows Forms app is a .NET assembly that uses the Windows Forms GUI class library: Windows Forms","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Get stream names","p":["Get a list of stream names.","Parameters:","-","Return value:","A list with stream names","Example:"]},{"l":"Resources check","p":["Check if assembly has resources.","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Get resources","p":["-","Example:","Get .NET (sub-)resources data and information.","Number of sub-resources","Parameters:","Resource data","Resource name","Resource size","Resource visibility. Options:","Return value:","Sub-resource data","Sub-resource detailed type information","Sub-resource name","Sub-resource size","Sub-resource type code. Options:","Sub-resource type details:","Sub-resource type. Options:","Sub-resources:","The resulting dictionary has the following and :"]},{"l":"Get runtime target version","p":["Get the .NET runtime target version of the assembly.","The .NET runtime (CLR) has its own version number beside .NET Framework/5/...:.NET Framework versions and dependencies","Parameters:","-","Return value:","Runtime target version string","Example:"]},{"l":"Get number of streams","p":["Get the number of metadata streams.","Parameters:","-","Return value:","Number of streams","Example:"]},{"l":"Get referenced libraries","p":["Get a list of all referenced libraries. This includes system, 3rd party and unmanaged libraries.","Parameters:","-","Return value:","List with library name strings","Example:"]},{"i":"get-strings-stream-strings","l":"Get #Strings stream strings","p":["Get all strings from the #Strings stream.","The #Strings heap contains all the names of the assembly, namespaces, types and members.","Parameters:","-","Return value:","List with #Strings stream strings","Example:"]},{"i":"get-us-stream-strings","l":"Get #US stream strings","p":["Get all strings from the #US stream.","The #US heap contains all strings directly defined by the programmer in method code. The strings are stored in Unicode format.","Parameters:","-","Return value:","List with #US stream strings","Example:"]},{"i":"get-strings-stream-string","l":"Get #Strings stream string","p":["Get a string from the #Streams heap string table of an assembly. This includes overlapping strings which are part of other strings, e.g. MyString in ThisIsMyString.","This method is more like an internal one, but might be still useful in some situations.","Parameters:","Address/index of the string in the #Strings stream","Return value:","#Strings stream string","Example:"]},{"l":"Get hash from strings","p":["Get a MD5, SHA-1 or SHA-256 hash from a list of strings.","This method is more like an internal one, but might be still useful in some situations.","Parameters:","Hash type (, or )","List with strings","Return value:","Hash as a string","Example:"]}],[{"l":"Anti metadata","p":["Contains various properties for anti-parsing tricks that .NET obfuscators like ConfuserEx use to confuse a PE viewer/parser."]},{"i":"net-data-directory-hidden","l":".NET data directory hidden","p":["Checks if the .NET data directory is hidden in the PE header. This is an old trick to confuse PE viewers/parsers (e.g. pefile) to properly analyze an assembly.","Usually, the value of NumberOfRvaAndSizes in the IMAGE_OPTIONAL_HEADER structure of a PE file is 0x10 (16). This value describes how many entries are in the following IMAGE_DATA_DIRECTORY structure. The last two entries are Reserved (16) and DIRECTORY_ENTRY_COM_DESCRIPTOR (15) that is the .NET data directory which contains the CLR header address and size. When you lower the NumberOfRvaAndSizes value to 0xE (14) to \"hide\" the last two entries in the data directories, you can confuse some PE viewer/parser and still have an executable .NET assembly.","1ef2be748b6798c547db0753918bb3e1ddbbc9e0b66b71c5a3eed1b04a8ed556","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Table header uses ExtraData","p":["Checks if the tables header in the #~ or #- stream uses the undocumented ExtraData field. Usually, the end of the Tables header is made of row count fields of the existing tables. However, there is an undocumented field ExtraData that can be appended at the end of this table. The purpose of these 4 extra bytes is unknown and also why the CLR loader allows them to be present.","ba0b2518a0073173f4940923af6e235eb8c392283903053d55e5dd31236a3b3d","Parameters:","-","Return value:","True or False","Example:"]},{"l":"TypeRef table has self-referencing entries","p":["Entries in the TypeRef table have a field named ResolutionScope that is a token. It encodes in which table the target type is defined and what index it has in the table. This token can also point to the TypeRef table itself. Obfuscators use this to add bogus entries that reference each other in the ResolutionScope field.","6f30280da560a30bbe25835f00d881dad94e5a7641b63e028080628c1f82a992","Parameters:","-","Return value:","True or False","Example:"]},{"l":"TypeRef table has invalid entries","p":["Entries in the TypeRef table have a field named ResolutionScope that is a token. It encodes in which table the target type is defined and what index it has in the table. This token can also point to the TypeRef table itself with an index that isn't available. This is abused by some obfuscators as the CLR loader doesn't check if the index exists. Furthermore, entries in the TypeRef table have a field named TypeName. It is an index to a string in the #Strings stream that is set to 0 by some obfuscators. Technically, this is correct as the #Streams stream always starts with an index 0. However, this index never contains a string, and thus it doesn't make sense to reference it.","6f30280da560a30bbe25835f00d881dad94e5a7641b63e028080628c1f82a992","Parameters:","-","Return value:","True or False","Example:"]},{"i":"net-header-has-fake-data-streams","l":".NET header has fake data streams","p":["Checks if a .NET assembly has fake data streams. Usually, an assembly has only the following streams:","#~ or #-","#Strings","#US","#GUID","#Blob","The CLR loader ignores any stream that is named differently and only parses the first occurring stream for one of the names above. Obfuscators sometimes add additional data streams with fake entries. These are either named similar to the original ones and placed before them. Or they're named identically, but follow afterward.","While the above streams are the common ones, there exist more streams which are however undocumented:.NET Runtime source code","6f30280da560a30bbe25835f00d881dad94e5a7641b63e028080628c1f82a992","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Module table has multiple rows","p":["According to the .NET specification, the Module table should contain only one row. However, obfuscators sometimes add an additional row with invalid entries. That's possible as the CLR loader doesn't validate if there's only one row present.","c64c9c62ec56ffded65ecf8585f98fd96e72027b0747b33dffc1e7b07065015a","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Assembly table has multiple rows","p":["According to the .NET specification, the Assembly table should contain only one row. However, obfuscators sometimes add an additional row with invalid entries. That's possible as the CLR loader doesn't validate if there's only one row present.","c64c9c62ec56ffded65ecf8585f98fd96e72027b0747b33dffc1e7b07065015a","Parameters:","-","Return value:","True or False","Example:"]},{"i":"strings-stream-has-invalid-entries","l":"#Strings stream has invalid entries","p":["Obfuscators sometimes add a row to the #Strings stream that has an invalid string reference. This points not to an actual string in the file, but to nowhere as the value is invalid. For example, the last row in the #Strings stream contains the value 0x7fff7fff as a reference which points to outside the file.","b1f26dce54fcdcf40fa5c65705698f81b23486d5adc4e4a035a07d074ce8e64d","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Stream names are mixed-case","p":["In the specification and in compiler generated assemblies, those stream names with characters are only shown in one notation that is #Strings, #US, #GUID, #Blob and so forth. This creates the impression that the names have to have this notation while they can actually have mixed-case characters at will. For example, an assembly can have the stream names #stRinGs and #bloB and still run fine. This trick is used by some obfuscators to confuse a parser.","b65f40618f584303ca0bcf9b5f88c233cc4237699c0c4bf40ba8facbe8195a46","Parameters:","-","Return value:","True or False","Example:"]},{"l":"MethodDef table has invalid entries","p":["This property checks if there are rows in the MethodDef table with the columns RVA, Flags, Name and Signature set to 0. While it's possible that some of these fields could have this value, all of them being set to zero indicates a bogus method added by some obfuscators.","55bcf947907068874f18870c331432b0336f0aa4821e992395790e5f3523b0d3","Parameters:","-","Return value:","True or False","Example:"]},{"i":"strings-stream-has-maximum-length-exceeding-strings","l":"#Strings stream has maximum length exceeding strings","p":["While there is no maximum length of strings in the #Strings stream defined in the .NET specification, it is effectively set to 1024 characters in the Roslyn compiler. Some obfuscators inject overly long nonsense strings to confuse parsers.","9621a729349b6c5df925ad8e7695b92bcec7c842cc9f01bd22cd75a57599cdd2","Parameters:","-","Return value:","True or False","Example:"]}],[{"l":"Header","p":["The CLR header contains several \"sub-headers\" such as the Cor20 header, the Storage header and the Tables header.","Header name","Supported in version","Cor20","0.1.0(partly)","Storage","-","Tables"]}],[{"l":"Cor20","p":["This header contains runtime-specific and various other information."]},{"l":"Entry point existence","p":["The Cor20 header has a field named EntryPointToken. This field contains the token of the managed entry point if not 0. The token encodes information in which row of the MethodDef table the entry point is located.",".NET executables always have an entry point defined in EntryPointToken, while it is optional for .NET DLLs in contrast to native PE DLLs.","Parameters:","-","Return value:","True or False","Example:"]},{"l":"Get entry point information","p":["-","Class ManagedEntryPoint:","Class NativeEntryPoint:","Example:","Gets information about the native or managed entry point. It checks if the .NET assembly has a native or managed entry point. In the latter case, it decodes the EntryPointToken and gets all the information of the method from the MethodDef and cross-referenced tables. This includes the method name along with the type, namespace and possible parameter(s).","Method has a \"this\" pointer","Method information:","Method name","Namespace name","Parameter(s)","Parameters:","Return value","Return value:","RVA of the entry point","The result can be one of the following dataclass objects or None:","Type name","Type of entry point","When a .NET assembly has a native entry point, it is a mixed assembly. Then, the RVA in the EntryPointToken points to the DllEntryPoint function that initializes the native part in case of a DLL."]}],[{"l":"Tables","p":["-","0.1.0","0.1.0(partly)","Assembly","AssemblyOS","AssemblyProcessor","AssemblyRef","AssemblyRefOS","AssemblyRefProcessor","ClassLayout","Constant","CustomAttribute","CustomDebugInformation","DeclSecurity","Document","Documented in CLI","EncLog","EncMap","Event","EventMap","EventPtr","ExportedType","Field","FieldLayout","FieldMarshal","FieldPtr","FieldRVA","File","GenericParam","GenericParamConstraint","ImplMap","ImportScope","InterfaceImpl","LocalConstant","LocalScope","LocalVariable","ManifestResource","MemberRef","MethodDebugInformation","MethodDef","MethodImpl","MethodPtr","MethodSemantics","MethodSpec","Module","ModuleRef","NestedClass","Param","ParamPtr","Property","PropertyMap","PropertyPtr","StandAloneSig","StateMachineMethod","Supported in version","Table name","The CLR header consists mainly of tables that all reside in the #~/- stream. While the CLI specification describes 38 tables, there are actually more which are however undocumented. The full list of tables is as follows:","TypeDef","TypeRef","TypeSpec"]}],[{"l":"Assembly","p":["The Assembly table contains various information about the assembly. An assembly is a module that contains a manifest in the metadata."]},{"l":"Get assembly name","p":["Get the assembly name.","Parameters:","-","Return value:","Assembly name","Example:"]},{"l":"Get assembly culture","p":["Get the assembly culture.","Parameters:","-","Return value:","Culture name","Example:"]},{"l":"Get assembly version information","p":["Get the assembly version information.","Parameters:","-","Return value:","The result is a AssemblyInfo dataclass object with the following values or None:","Major version number","Minor version number","Build number","Revision number","Example:"]}],[{"l":"AssemblyRef","p":["The AssemblyRef table contains various information about other referenced external assemblies."]},{"l":"Get referenced assemblies","p":["Get a list of referenced assembly names.","Parameters:","De-duplicate names.","Return value:","A list with referenced assembly names","Example:"]},{"l":"Get referenced cultures","p":["Get a list of referenced culture names.","Parameters:","-","Return value:","A list with referenced culture names","Example:"]}],[{"l":"Event","p":["The Event table contains various information about defined events."]},{"l":"Get event names","p":["Get a list of event names.","Parameters:","-","Return value:","A list with event names","Example:"]}],[{"l":"ImplMap","p":["The ImplMap table contains various information about unmanaged functions statically imported via P/Invoke."]},{"l":"Get unmanaged function names","p":["Get a list of unmanaged function names as is. We ignore the CharSet field values in the table rows and don't make any assumptions on it (...A/W function or no charset).","We made some tests to understand how this field is filled by the Visual C# compiler with the following results:","For ANSI only functions, it doesn't matter what CharSet value you set in the C# definition. You can even use Unicode and it still works.","ANSI only functions can't be \"name\" defined, meaning you can't use GetProcAddressA as function name no matter what you set in CharSet.","As a result, we have to ignore the CharSet field as it's not a reliable value for the function charset determination. It's not possible to determine if a function is an ANSI only one based on the field value. It's only possible to determine for Unicode functions (...W), but having only this possibility is inconsistent.","Parameters:","-","Return value:","A list with unmanaged function names","Example:"]}],[{"l":"ManifestResource","p":["The ManifestResource table contains various information about .NET resources."]},{"l":"Get resource names","p":["Get a list of resource names.","Parameters:","-","Return value:","A list with resource names","Example:"]}],[{"l":"MemberRef","p":["The MemberRef table contains various information about referenced members."]},{"l":"Get referenced member names","p":["Get a list of referenced member names.","Parameters:","De-duplicate names (off by default)","Return value:","A list with referenced member names","Example:"]},{"l":"Get MemberRef hash","p":["The MemberRef hash is a hash of reference (to methods and fields of a class) and table names of their corresponding classes. We take the table name of the belonging class and the reference name to create a string pair separated by a \"-\" character. This table<->name string pair is added to a list and the hash value is calculated at the end. The class always belongs to one of the five tables 'TypeDef', 'TypeRef', 'ModuleRef', 'MethodDef' or 'TypeSpec'.","The list of table and reference names can be sorted alphabetically after the reference names before being hashed. Strings are used case-sensitive.","This is a purely experimental hash and hasn't been tested for file identification purposes yet. It might not be very reliable, so use it at your own risk!","Parameters:","Hash algortihm. Options:","(on by default)","Sort string pairs alphabetically after the referenced member names (off by default)","Return value:","A MemberRef hash as a hexadecimal string","Example:"]}],[{"l":"MethodDef","p":["The MethodDef table contains various information about defined methods."]},{"l":"Get defined method names","p":["Get a list of defined method names.","Parameters:","The access level of the defined methods. Options:","(on by default)","Return value:","A list with defined methods names","Example:"]},{"l":"Get Windows Forms app entry point","p":["Get the entry point of a Windows forms app.","This method is more like an internal one, but might be still useful in some situations.","Parameters:","-","Return value:","The result is a list with a EntryPoint dataclass object with the following values:","Method name","Additional method information:","Method has a \"this\" pointer","Return value","Parameter(s)","Type name","Namespace name","Example:"]},{"i":"get-possible-entry-points-dll","l":"Get possible entry points (DLL)","p":["Get a list of possible entry points (public methods) of a .NET DLL along with their types, namespace and parameters.",".NET DLLs don't need to have a defined entry point in contrast to native PE DLLs that always have the DllMain function. Without knowing the real entry point, the execution of a .NET DLL likely won't work or will result in a crash. In order to be able to make a dynamic analysis of these files and fully detonate them, you have to call the supposed entry point method(s).","Parameters:","-","Return value:","The result is a list with EntryPoint dataclass objects:","Method name","Additional method information:","Method has a \"this\" pointer","Return value","Parameter(s)","Type name","Namespace name","Example:"]}],[{"l":"Module","p":["The Module table contains various information about the module. All Common Intermediate Language (CIL) files are referred to as modules."]},{"l":"Get module name","p":["Get the module name of the assembly","Parameters:","-","Return value:","Module name","Example:"]}],[{"l":"ModuleRef","p":["The ModuleRef table contains information about unmanaged modules (DLLs)."]},{"l":"Get unmanaged module names","p":["Get a list with unmanaged module names.","Parameters:","Module names output. Options:","Get module names as they are and append to the list (on by default)","Add .dll extension to module names if necessary, lowercase them and remove duplicates","Return value:","A list with unmanaged module names","Example:"]}],[{"l":"TypeDef","p":["The TypeDef table contains various information about defined types."]},{"l":"Get defined type names","p":["Get a list of defined type names.","Parameters:","The visibility of the defined types. Options:","(on by default)","Return value:","A list with defined type names","Example:"]},{"l":"Get defined type names with methods","p":["-","Additional method information:","Example:","Get a list of defined type names with their corresponding methods.","Method flags","Method has a \"this\" pointer","Method information:","Method name","Namespace name","Parameter(s)","Parameters:","Return value","Return value:","The result is a list of TypesMethods dataclass objects with the following values:","This method is more like an internal one, but might be still useful in some situations.","Type flags","Type name"]}],[{"l":"TypeRef","p":["The TypeRef table contains various information about referenced types."]},{"l":"Get referenced type names","p":["Get a list of referenced type names.","Parameters:","-","Return value:","A list with referenced type names","Example:"]},{"l":"Get TypeRef hash","p":["Get the TypeRef hash that is a modified version of the original GData implementation. It uses the resolution scope names instead of the namespace names as they're always present. Additionally, there is an option to skip types that reference each other as added by some .NET protectors. Lastly, you can also sort the type names alphabetically before they get hashed. Strings are used case-sensitive as in the original implementation.","Parameters:","Hash algorithm. Options:","(on by default)","Skip types that reference each other (on by default)","Sort type name strings alphabetically (off by default)","Return value:","A TypeRef hash as a hexadecimal string","Example:"]}],[{"l":"Release notes"},{"l":"v0.2.4","p":["Added (internal) get_user_string() method, see #3","Added method header parser to get RVA, header/code size and raw IL bytes","Available on PyPI #2","Better error handling for corrupt resources","Detection and support for more anti metadata/parsing tricks","DotNetPEParser handles PathLike objects, see #4","Fast-load","Fixed sorting in TypeRef hash method","get_string() method better handles obfuscator tricks","Invalid entries in MethodDef table","Maximum length exceeding strings in #Strings stream","Mixed case stream names","Released: 2023-08-11","Simple disassembler code example","Thanks to all contributors!","Typo fixes in documentation, see #5+ #6","Various other small fixes"]},{"i":"v010","l":"v0.1.0","p":["Released: 2022-05-30","Initial public release"]}],[{"l":"About","p":["This project was started in 2016 with the development of the parser library for internal use at Palo Alto Networks. It was improved/extended with the interface library and open-sourced in 2022 by the following people:","Bob Jung (parser library)","Yaron Samuel (parser library) ▪️ @yaron_samuel","Dominik Reichel (parser and interface libraries) ▪️ @TheEnergyStory"]}]]